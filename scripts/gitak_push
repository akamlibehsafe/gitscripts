#!/bin/bash

# gitak_push
# Commits and pushes changes from a local Git repository,
# automatically detecting the repository owner.

set -e  # Exit on error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print error messages
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

# Function to print success messages
success() {
    echo -e "${GREEN}$1${NC}"
}

# Function to print info messages
info() {
    echo -e "${YELLOW}$1${NC}"
}

# Function to print prompt messages
prompt() {
    echo -e "${BLUE}$1${NC}"
}

# Parse arguments
TARGET_DIR=""
COMMIT_MESSAGE=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -m|--message)
            COMMIT_MESSAGE="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: gitak_push [directory] [-m|--message \"commit message\"]"
            echo ""
            echo "Options:"
            echo "  directory              Path to git-enabled folder (defaults to current directory)"
            echo "  -m, --message MESSAGE  Commit message (if not provided, will prompt interactively)"
            echo "  -h, --help             Show this help message"
            exit 0
            ;;
        *)
            if [ -z "$TARGET_DIR" ]; then
                TARGET_DIR="$1"
            else
                error "Unexpected argument: $1\nUse -h for help"
            fi
            shift
            ;;
    esac
done

# Determine target directory
if [ -z "$TARGET_DIR" ]; then
    TARGET_DIR=$(pwd)
else
    # Convert to absolute path
    if [ ! -d "$TARGET_DIR" ]; then
        error "Directory does not exist: $TARGET_DIR"
    fi
    TARGET_DIR=$(cd "$TARGET_DIR" && pwd -P)
fi

info "Target directory: $TARGET_DIR"

# Verify the directory is a Git repository
if [ ! -d "$TARGET_DIR/.git" ]; then
    error "Not a Git repository: $TARGET_DIR\nPlease run this script from a Git repository or specify a valid Git repository path."
fi

# Handle Git safe.directory issue for /tmp and other potentially problematic directories
if [[ "$TARGET_DIR" =~ ^/tmp|^/private/tmp|^/var/tmp ]]; then
    info "Detected temporary directory, ensuring Git safe.directory configuration..."
    SAFE_DIRS=$(git config --global --get-all safe.directory 2>/dev/null || echo "")
    if [ -z "$SAFE_DIRS" ] || ! echo "$SAFE_DIRS" | grep -Fxq "$TARGET_DIR"; then
        git config --global --add safe.directory "$TARGET_DIR"
        info "Added $TARGET_DIR to Git safe.directory list"
    fi
fi

# Change to target directory
cd "$TARGET_DIR"
info "Working in: $(pwd)"

# Check if git is installed
if ! command -v git &> /dev/null; then
    error "Git is not installed. Please run gitak_install first."
fi

# Check if remote is configured
if ! git remote get-url origin &>/dev/null; then
    error "No remote 'origin' configured.\nPlease add a remote:\ngit remote add origin <repository-url>"
fi

# Get remote URL
REMOTE_URL=$(git remote get-url origin)
info "Remote URL: $REMOTE_URL"

# Extract username and repository name from remote URL
# Handle both HTTPS and SSH formats:
# https://github.com/user/repo.git
# https://user@github.com/user/repo.git
# https://token@github.com/user/repo.git
# git@github.com:user/repo.git

USERNAME=""
REPO_NAME=""

# Try to extract from HTTPS URL
if [[ "$REMOTE_URL" =~ https://.*github\.com[:/]([^/]+)/([^/]+)(\.git)?$ ]]; then
    USERNAME="${BASH_REMATCH[1]}"
    REPO_NAME="${BASH_REMATCH[2]}"
    # Remove .git suffix if present
    REPO_NAME="${REPO_NAME%.git}"
# Try to extract from SSH URL
elif [[ "$REMOTE_URL" =~ git@github\.com:([^/]+)/([^/]+)(\.git)?$ ]]; then
    USERNAME="${BASH_REMATCH[1]}"
    REPO_NAME="${BASH_REMATCH[2]}"
    # Remove .git suffix if present
    REPO_NAME="${REPO_NAME%.git}"
else
    error "Could not parse remote URL: $REMOTE_URL\nExpected format: https://github.com/user/repo.git or git@github.com:user/repo.git"
fi

if [ -z "$USERNAME" ] || [ -z "$REPO_NAME" ]; then
    error "Failed to extract username and repository name from remote URL"
fi

info "Detected repository: $USERNAME/$REPO_NAME"

# Determine which PAT to use based on detected username
if [ "$USERNAME" = "fortegb" ]; then
    PAT_VAR="GH_TOKEN_fortegb"
elif [ "$USERNAME" = "akamlibehsafe" ]; then
    PAT_VAR="GH_TOKEN_akamlibehsafe"
else
    error "Unknown username: $USERNAME\nSupported users: fortegb, akamlibehsafe\nDetected from remote: $REMOTE_URL"
fi

# Retrieve PAT from environment
PAT="${!PAT_VAR}"

if [ -z "$PAT" ]; then
    error "PAT variable $PAT_VAR is not set.\nPlease set it in your shell configuration:\nexport $PAT_VAR=\"your_token_here\""
fi

info "Using PAT from: $PAT_VAR"

# Check if Git LFS is installed and configure credentials if needed
if command -v git-lfs &> /dev/null || command -v git lfs &> /dev/null; then
    # Check if there are LFS files in the repository
    if git lfs ls-files &>/dev/null && [ -n "$(git lfs ls-files 2>/dev/null)" ]; then
        info "Git LFS files detected, configuring LFS credentials..."
        
        # Disable LFS locking API (not needed for GitHub)
        git config lfs.https://github.com/${USERNAME}/${REPO_NAME}.git/info/lfs.locksverify false 2>/dev/null || true
        
        # Configure Git credential helper if not already configured
        if ! git config --global credential.helper &>/dev/null; then
            # Try osxkeychain on macOS, fallback to store
            if [[ "$OSTYPE" == "darwin"* ]]; then
                git config --global credential.helper osxkeychain 2>/dev/null || \
                git config --global credential.helper store 2>/dev/null || true
            else
                git config --global credential.helper store 2>/dev/null || true
            fi
        fi
        
        # Store credentials for Git LFS
        printf "protocol=https\nhost=github.com\nusername=${USERNAME}\npassword=${PAT}\n" | git credential approve 2>/dev/null || true
        
        info "LFS credentials configured"
    fi
fi

# Get current branch
CURRENT_BRANCH=$(git branch --show-current)
if [ -z "$CURRENT_BRANCH" ]; then
    error "Not on any branch. Please checkout a branch first."
fi

info "Current branch: $CURRENT_BRANCH"

# Check for changes
HAS_CHANGES=false
HAS_STAGED=false
HAS_UNSTAGED=false
HAS_UNTRACKED=false

# Check for staged changes
if ! git diff --staged --quiet 2>/dev/null; then
    HAS_STAGED=true
    HAS_CHANGES=true
fi

# Check for unstaged changes
if ! git diff --quiet 2>/dev/null; then
    HAS_UNSTAGED=true
    HAS_CHANGES=true
fi

# Check for untracked files
if [ -n "$(git ls-files --others --exclude-standard)" ]; then
    HAS_UNTRACKED=true
    HAS_CHANGES=true
fi

# Stage all changes if there are any
if [ "$HAS_CHANGES" = true ]; then
    info "Staging changes..."
    git add .
    success "Changes staged"
    
    # Show what will be committed
    if [ "$HAS_STAGED" = true ] || [ "$HAS_UNSTAGED" = true ] || [ "$HAS_UNTRACKED" = true ]; then
        info "Changes to be committed:"
        git status --short
    fi
    
    # Get commit message
    if [ -z "$COMMIT_MESSAGE" ]; then
        prompt "\nEnter commit message (or press Enter for default):"
        read -r COMMIT_MESSAGE
    fi
    
    # Use default message if empty
    if [ -z "$COMMIT_MESSAGE" ]; then
        COMMIT_MESSAGE="Update from local - $(date '+%Y-%m-%d %H:%M:%S')"
        info "Using default commit message: $COMMIT_MESSAGE"
    fi
    
    # Create commit
    info "Creating commit..."
    if git commit -m "$COMMIT_MESSAGE"; then
        success "Commit created successfully"
    else
        error "Failed to create commit"
    fi
else
    info "No changes to commit"
fi

# Store original remote URL
ORIGINAL_REMOTE=$(git remote get-url origin)

# For LFS, we use clean URL with credential helper
# For regular git, we can use PAT in URL temporarily
# Check if we have LFS files
HAS_LFS_FILES=false
if command -v git-lfs &> /dev/null || command -v git lfs &> /dev/null; then
    if git lfs ls-files &>/dev/null && [ -n "$(git lfs ls-files 2>/dev/null)" ]; then
        HAS_LFS_FILES=true
    fi
fi

# Set remote URL appropriately
if [ "$HAS_LFS_FILES" = true ]; then
    # For LFS, use clean URL (credentials handled by credential helper)
    git remote set-url origin "https://github.com/${USERNAME}/${REPO_NAME}.git"
else
    # For regular git, use PAT in URL temporarily
    AUTH_REMOTE="https://${PAT}@github.com/${USERNAME}/${REPO_NAME}.git"
    git remote set-url origin "$AUTH_REMOTE"
fi

# Push to remote
info "Pushing to remote repository..."
if [ "$HAS_LFS_FILES" = true ]; then
    info "Pushing with Git LFS support..."
fi
set +e
git push -u origin "$CURRENT_BRANCH" 2>&1
PUSH_ERROR=$?
set -e

# Restore original remote URL
git remote set-url origin "$ORIGINAL_REMOTE"

if [ $PUSH_ERROR -eq 0 ]; then
    success "Successfully pushed to remote repository"
    success "Repository: https://github.com/$USERNAME/$REPO_NAME"
else
    error "Failed to push to remote repository"
fi

