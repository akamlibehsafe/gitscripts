#!/bin/bash

# environment_install
# Comprehensive installation script that orchestrates the installation of all
# development tools and configurations including Git, Zsh, iTerm2, Cursor, etc.

set -e  # Exit on error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
NC='\033[0m' # No Color

# Function to print error messages
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

# Function to print success messages
success() {
    echo -e "${GREEN}$1${NC}"
}

# Function to print info messages
info() {
    echo -e "${YELLOW}$1${NC}"
}

# Function to print prompt messages
prompt() {
    echo -e "${BLUE}$1${NC}"
}

# Function to print section headers
section() {
    echo ""
    echo -e "${BLUE}=== $1 ===${NC}"
    echo ""
}

# Check if running on macOS
if [[ "$OSTYPE" != "darwin"* ]]; then
    error "This script is designed for macOS only. Detected OS: $OSTYPE"
fi

info "Starting Environment Installation for macOS..."
info "This script will install and configure all development tools and settings."

# Detect shell type for configuration file
SHELL_NAME=$(basename "$SHELL")
SHELL_CONFIG=""

if [[ "$SHELL_NAME" == "zsh" ]]; then
    SHELL_CONFIG="$HOME/.zshrc"
elif [[ "$SHELL_NAME" == "bash" ]]; then
    SHELL_CONFIG="$HOME/.bashrc"
    if [ -f "$HOME/.bash_profile" ] && [ ! -f "$HOME/.bashrc" ]; then
        SHELL_CONFIG="$HOME/.bash_profile"
    fi
else
    info "Warning: Unknown shell '$SHELL_NAME'. Defaulting to .zshrc"
    SHELL_CONFIG="$HOME/.zshrc"
fi

info "Detected shell: $SHELL_NAME"
info "Configuration file: $SHELL_CONFIG"

# Get script directory (where the script is located)
# This works whether the script is in a git repository or extracted from a zip file
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"
# Parent directory (repository root if in git repo, or extracted folder root if from zip)
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd -P)"

section "PAT Configuration"

# Ask about PATs FIRST, before any tool installation
prompt "Do you have Personal Access Tokens generated from GitHub? (Y/n)"
read -r HAS_PATS

if [[ "$HAS_PATS" =~ ^[Nn]$ ]]; then
    # User doesn't have PATs - show instructions
    info "You'll need to generate Personal Access Tokens before proceeding."
    echo ""
    prompt "Instructions to generate PATs:"
    echo ""
    echo "1. Go to GitHub â†’ Settings â†’ Developer settings â†’ Personal access tokens â†’ Tokens (classic)"
    echo "2. Click 'Generate new token (classic)'"
    echo "3. Give it a descriptive name (e.g., 'Git Automation Scripts')"
    echo "4. Select expiration: No expiration"
    echo "5. Select scopes: âœ“ Check all checkmarks (especially 'repo' scope)"
    echo "6. Click 'Generate token' and COPY the token immediately (you won't see it again)"
    echo ""
    echo "Required tokens:"
    echo "  â€¢ GH_TOKEN_fortegb - for the 'fortegb' account"
    echo "  â€¢ GH_TOKEN_akamlibehsafe - for the 'akamlibehsafe' account"
    echo ""
    echo "Important: Classic version, no expiration, all checkmarks checked"
    echo ""
    prompt "Generate the PATs now, then press Enter to continue..."
    read -r
    PATS_FILE=""
else
    # User has PATs - ask for filename
    prompt "What is the filename containing your PAT tokens? (default: PAT.md)"
    read -r PATS_FILENAME
    
    if [ -z "$PATS_FILENAME" ]; then
        PATS_FILENAME="PAT.md"
    fi
    
    # Check if file exists (prioritize script directory, then current directory, then parent)
    if [ -f "$SCRIPT_DIR/$PATS_FILENAME" ]; then
        PATS_FILE="$SCRIPT_DIR/$PATS_FILENAME"
        info "Found PAT file: $PATS_FILE"
    elif [ -f "$PATS_FILENAME" ]; then
        PATS_FILE="$PATS_FILENAME"
        info "Found PAT file: $PATS_FILE"
    elif [ -f "$REPO_ROOT/$PATS_FILENAME" ]; then
        PATS_FILE="$REPO_ROOT/$PATS_FILENAME"
        info "Found PAT file: $PATS_FILE"
    else
        info "PAT file '$PATS_FILENAME' not found in script directory, current directory, or parent directory."
        info "Will check in gitscripts repository after it's cloned."
        PATS_FILE="$PATS_FILENAME"
    fi
fi

section "Step 1: Homebrew Installation"

# Check if Homebrew is installed
if command -v brew &> /dev/null; then
    success "Homebrew is already installed"
    info "Updating Homebrew..."
    brew update || info "Homebrew update skipped (may require manual intervention)"
else
    info "Homebrew is not installed. Installing Homebrew..."
    info "This will prompt for your password..."
    
    # Install Homebrew
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" || {
        error "Homebrew installation failed. Please install manually from https://brew.sh"
    }
    
    # Add Homebrew to PATH if not already there
    if [[ -f "/opt/homebrew/bin/brew" ]]; then
        export PATH="/opt/homebrew/bin:$PATH"
        info "Added Homebrew to PATH for this session"
    elif [[ -f "/usr/local/bin/brew" ]]; then
        export PATH="/usr/local/bin:$PATH"
        info "Added Homebrew to PATH for this session"
    fi
    
    success "Homebrew installed successfully"
fi

# Verify brew is in PATH
if ! command -v brew &> /dev/null; then
    error "Homebrew installation completed but 'brew' command not found in PATH.\nPlease add Homebrew to your PATH:\n  For Apple Silicon: export PATH=\"/opt/homebrew/bin:\$PATH\"\n  For Intel: export PATH=\"/usr/local/bin:\$PATH\""
fi

BREW_VERSION=$(brew --version | head -n1)
success "Homebrew ready: $BREW_VERSION"

section "Step 2: Git Root Directory Setup"

GIT_ROOT_DIR="$HOME/Documents/GitHub"

if [ -d "$GIT_ROOT_DIR" ]; then
    success "Git root directory already exists: $GIT_ROOT_DIR"
else
    info "Creating Git root directory: $GIT_ROOT_DIR"
    mkdir -p "$GIT_ROOT_DIR" || error "Failed to create directory: $GIT_ROOT_DIR"
    success "Created Git root directory: $GIT_ROOT_DIR"
fi

section "Step 3: Git, Git LFS, and GitHub CLI Installation"

# Run gitak_install script
GITAK_INSTALL_SCRIPT="$REPO_ROOT/scripts/gitak_install"

if [ ! -f "$GITAK_INSTALL_SCRIPT" ]; then
    # Check if we're in the gitscripts repo
    if [ -f "$SCRIPT_DIR/gitak_install" ]; then
        GITAK_INSTALL_SCRIPT="$SCRIPT_DIR/gitak_install"
    else
        error "gitak_install script not found. Expected at: $GITAK_INSTALL_SCRIPT"
    fi
fi

info "Running gitak_install..."
set +e  # Temporarily disable exit on error to check status
bash "$GITAK_INSTALL_SCRIPT"
GITAK_STATUS=$?
set -e  # Re-enable exit on error

if [ $GITAK_STATUS -ne 0 ]; then
    error "gitak_install failed with exit code $GITAK_STATUS"
fi

success "Git, Git LFS, and GitHub CLI installation completed"

# Determine gitscripts repository location (gitak_install clones it)
GITSCRIPTS_REPO="$GIT_ROOT_DIR/akamlibehsafe/gitscripts"

section "Step 4: Clone All Repositories from GitHub Accounts"

# Try to load PAT tokens from shell config (they might have been added by gitak_install)
if [ -f "$SHELL_CONFIG" ]; then
    # Source the shell config to load PAT tokens (in a subshell to avoid side effects)
    set +e
    source "$SHELL_CONFIG" 2>/dev/null || true
    set -e
fi

# Check if PAT tokens are available
GH_TOKEN_FORTEGB="${GH_TOKEN_fortegb:-}"
GH_TOKEN_AKAMLIBEHSAFE="${GH_TOKEN_akamlibehsafe:-}"

if [ -z "$GH_TOKEN_FORTEGB" ] && [ -z "$GH_TOKEN_AKAMLIBEHSAFE" ]; then
    info "PAT tokens not found in environment variables."
    info "Repository cloning will be skipped."
    info "You can clone repositories manually later or run this script again after configuring PAT tokens."
else
    prompt "Would you like to clone all repositories from both GitHub accounts? (Y/n)"
    read -r CLONE_REPOS
    
    if [[ ! "$CLONE_REPOS" =~ ^[Nn]$ ]]; then
        # Check if jq is available (needed for parsing JSON)
        if ! command -v jq &> /dev/null; then
            info "jq is not installed. Installing jq..."
            if command -v brew &> /dev/null; then
                brew install jq || info "Failed to install jq. Repository cloning will be limited."
            else
                info "Homebrew not found. Cannot install jq. Repository cloning will be limited."
            fi
        fi
        
        # Function to clone repositories for a user
        clone_user_repos() {
            local username="$1"
            local pat="$2"
            local user_dir="$GIT_ROOT_DIR/$username"
            
            if [ -z "$pat" ]; then
                info "PAT token for $username not available. Skipping..."
                return
            fi
            
            # Create user directory if it doesn't exist
            mkdir -p "$user_dir" || error "Failed to create directory: $user_dir"
            
            info "Fetching repositories for $username..."
            
            # Get all repositories using GitHub API with pagination
            page=1
            per_page=100
            
            while true; do
                # Fetch repositories page
                API_RESPONSE=$(curl -s -w "\n%{http_code}" \
                    -H "Accept: application/vnd.github.v3+json" \
                    -H "Authorization: token $pat" \
                    "https://api.github.com/user/repos?per_page=$per_page&page=$page&type=all")
                
                HTTP_CODE=$(echo "$API_RESPONSE" | tail -n1)
                API_BODY=$(echo "$API_RESPONSE" | sed '$d')
                
                if [ "$HTTP_CODE" -ne 200 ]; then
                    info "Failed to fetch repositories (HTTP $HTTP_CODE). Skipping $username..."
                    break
                fi
                
                # Check if response is empty (no more pages)
                if command -v jq &> /dev/null; then
                    REPO_COUNT=$(echo "$API_BODY" | jq 'length' 2>/dev/null || echo "0")
                    if [ "$REPO_COUNT" -eq 0 ]; then
                        break
                    fi
                    
                    # Parse and clone each repository
                    # Use process substitution to avoid subshell issues
                    while IFS='|' read -r repo_name clone_url; do
                        if [ -z "$repo_name" ] || [ -z "$clone_url" ]; then
                            continue
                        fi
                        
                        repo_path="$user_dir/$repo_name"
                        
                        if [ -d "$repo_path" ]; then
                            info "Repository $username/$repo_name already exists. Skipping..."
                        else
                            info "Cloning $username/$repo_name..."
                            set +e
                            # Use PAT in clone URL
                            CLONE_URL_WITH_AUTH="${clone_url/https:\/\//https://${pat}@}"
                            git clone "$CLONE_URL_WITH_AUTH" "$repo_path" 2>&1 | grep -v "^Cloning into" || true
                            CLONE_ERROR=$?
                            set -e
                            
                            if [ $CLONE_ERROR -eq 0 ]; then
                                success "Cloned $username/$repo_name"
                            else
                                info "Failed to clone $username/$repo_name (may require different authentication)"
                            fi
                        fi
                    done < <(echo "$API_BODY" | jq -r '.[] | "\(.name)|\(.clone_url)"' 2>/dev/null)
                else
                    # Fallback if jq is not available - try basic parsing (limited functionality)
                    info "jq not available. Cannot parse repository list automatically."
                    info "Please install jq: brew install jq"
                    break
                fi
                
                # Check if we got fewer repos than per_page (last page)
                if [ "$REPO_COUNT" -lt "$per_page" ]; then
                    break
                fi
                
                page=$((page + 1))
            done
            
            success "Repository cloning completed for $username"
        }
        
        # Clone repositories for both accounts
        if [ -n "$GH_TOKEN_FORTEGB" ]; then
            clone_user_repos "fortegb" "$GH_TOKEN_FORTEGB"
        fi
        
        if [ -n "$GH_TOKEN_AKAMLIBEHSAFE" ]; then
            clone_user_repos "akamlibehsafe" "$GH_TOKEN_AKAMLIBEHSAFE"
        fi
        
        success "Repository cloning step completed"
    else
        info "Repository cloning skipped"
    fi
fi

section "Step 5: Zsh, Oh My Zsh, and Powerlevel10k Installation"

# Run zsh_install script
ZSH_INSTALL_SCRIPT="$REPO_ROOT/scripts/zsh_install"

if [ ! -f "$ZSH_INSTALL_SCRIPT" ]; then
    # Check if we're in the gitscripts repo
    if [ -f "$SCRIPT_DIR/zsh_install" ]; then
        ZSH_INSTALL_SCRIPT="$SCRIPT_DIR/zsh_install"
    else
        # Check cloned repo location
        if [ -f "$GITSCRIPTS_REPO/scripts/zsh_install" ]; then
            ZSH_INSTALL_SCRIPT="$GITSCRIPTS_REPO/scripts/zsh_install"
        else
            error "zsh_install script not found. Expected at: $ZSH_INSTALL_SCRIPT"
        fi
    fi
fi

info "Running zsh_install..."
set +e  # Temporarily disable exit on error to check status
bash "$ZSH_INSTALL_SCRIPT"
ZSH_STATUS=$?
set -e  # Re-enable exit on error

if [ $ZSH_STATUS -ne 0 ]; then
    error "zsh_install failed with exit code $ZSH_STATUS"
fi

success "Zsh, Oh My Zsh, and Powerlevel10k installation completed"

section "Step 6: Cursor Desktop Installation"

prompt "Would you like to install Cursor Desktop? (Y/n)"
read -r INSTALL_CURSOR

if [[ ! "$INSTALL_CURSOR" =~ ^[Nn]$ ]]; then
    info "Installing Cursor Desktop..."
    
    if brew install --cask cursor; then
        success "Cursor Desktop installed successfully"
    else
        info "Cursor Desktop installation failed or was skipped"
    fi
else
    info "Cursor Desktop installation skipped"
fi

section "Symlinks Setup"

# Check if gitscripts repo exists (required for symlinks)
if [ ! -d "$GITSCRIPTS_REPO" ]; then
    info "gitscripts repository not found at: $GITSCRIPTS_REPO"
    info "Symlinks setup will be skipped"
else
    prompt "Would you like to set up symlinks in ~/bin/? (Y/n)"
    read -r SETUP_SYMLINKS
    
    if [[ ! "$SETUP_SYMLINKS" =~ ^[Nn]$ ]]; then
        # Check if ~/bin exists
        if [ ! -d "$HOME/bin" ]; then
            prompt "~/bin doesn't exist. Create it? (Y/n)"
            read -r CREATE_BIN
            
            if [[ ! "$CREATE_BIN" =~ ^[Nn]$ ]]; then
                mkdir -p "$HOME/bin" || error "Failed to create ~/bin directory"
                success "Created ~/bin directory"
            else
                info "Skipping symlinks setup (~/bin not created)"
                SETUP_SYMLINKS="n"
            fi
        else
            info "~/bin directory already exists"
        fi
        
        if [[ ! "$SETUP_SYMLINKS" =~ ^[Nn]$ ]]; then
            SETUP_SYMLINKS_SCRIPT="$GITSCRIPTS_REPO/scripts/gitak_setup_symlinks"
            
            if [ -f "$SETUP_SYMLINKS_SCRIPT" ]; then
                info "Running symlink setup script..."
                bash "$SETUP_SYMLINKS_SCRIPT"
                success "Symlinks setup completed"
            else
                error "gitak_setup_symlinks script not found at: $SETUP_SYMLINKS_SCRIPT"
            fi
        fi
    else
        info "Symlinks setup skipped"
    fi
fi

section "Adding Useful Aliases"

# Add aliases to ~/.zshrc
# Note: zsh_install should have created .zshrc by now, but handle both cases
if [ ! -f "$HOME/.zshrc" ]; then
    info "Creating ~/.zshrc file..."
    touch "$HOME/.zshrc"
fi

# Check if aliases already exist
if grep -q 'alias cdg=' "$HOME/.zshrc" 2>/dev/null; then
    info "Aliases already exist in ~/.zshrc"
else
    info "Adding useful aliases to ~/.zshrc..."
    {
        echo ""
        echo "# Useful aliases for Git repositories"
        echo "# Added by environment_install script on $(date)"
        echo "alias cdg=\"cd ~/Documents/GitHub\""
        echo "alias cda=\"cd ~/Documents/GitHub/akamlibehsafe\""
        echo "alias cdf=\"cd ~/Documents/GitHub/fortegb\""
        echo "alias cds=\"cd ~/Documents/GitHub/akamlibehsafe/shutterzilla\""
    } >> "$HOME/.zshrc"
    success "Aliases added to ~/.zshrc"
fi

section "ZSH Configuration"

prompt "Would you like to configure Powerlevel10k now? (Y/n)"
read -r CONFIGURE_P10K

if [[ ! "$CONFIGURE_P10K" =~ ^[Nn]$ ]]; then
    info "Running p10k configure..."
    if command -v p10k &> /dev/null; then
        p10k configure
        success "Powerlevel10k configuration completed"
    else
        info "p10k command not found. You may need to reload your shell first:"
        echo "  source ~/.zshrc"
        echo "  Then run: p10k configure"
    fi
else
    info "Powerlevel10k configuration skipped"
    info "You can configure Powerlevel10k anytime by running: p10k configure"
fi

section "iTerm2 Configuration Import"

prompt "Would you like to import iTerm2 configuration now? (Y/n)"
read -r IMPORT_ITERM2

if [[ ! "$IMPORT_ITERM2" =~ ^[Nn]$ ]]; then
    ITERM2_CONFIG_FILE=""
    
    # Check in current repo location
    if [ -f "$REPO_ROOT/config/iterm2/iTerm2 State.itermexport" ]; then
        ITERM2_CONFIG_FILE="$REPO_ROOT/config/iterm2/iTerm2 State.itermexport"
    elif [ -f "$GITSCRIPTS_REPO/config/iterm2/iTerm2 State.itermexport" ]; then
        ITERM2_CONFIG_FILE="$GITSCRIPTS_REPO/config/iterm2/iTerm2 State.itermexport"
    elif [ -f "$SCRIPT_DIR/../config/iterm2/iTerm2 State.itermexport" ]; then
        ITERM2_CONFIG_FILE="$(cd "$SCRIPT_DIR/.." && pwd)/config/iterm2/iTerm2 State.itermexport"
    fi
    
    if [ -n "$ITERM2_CONFIG_FILE" ] && [ -f "$ITERM2_CONFIG_FILE" ]; then
        info "Found iTerm2 configuration file: $ITERM2_CONFIG_FILE"
        echo ""
        prompt "To import iTerm2 configuration:"
        echo "1. Double-click the file: $ITERM2_CONFIG_FILE"
        echo "   OR go to iTerm2 â†’ File â†’ Import JSON Settings and select the file"
        echo "2. Follow the import wizard"
        echo ""
        
        # Optionally open Finder to the file location
        prompt "Open Finder to the file location? (Y/n)"
        read -r OPEN_FINDER
        if [[ ! "$OPEN_FINDER" =~ ^[Nn]$ ]]; then
            open -R "$ITERM2_CONFIG_FILE" 2>/dev/null || info "Could not open Finder"
        fi
    else
        info "iTerm2 configuration file not found at: config/iterm2/iTerm2 State.itermexport"
        info "You can import iTerm2 configuration later by double-clicking: config/iterm2/iTerm2 State.itermexport"
    fi
else
    info "iTerm2 configuration import skipped"
    info "You can import iTerm2 configuration later by double-clicking: config/iterm2/iTerm2 State.itermexport"
fi

section "Installation Complete!"

success "Environment installation completed successfully!"
echo ""

info "Installed/Configured components:"
echo "  âœ“ Homebrew"
echo "  âœ“ Git, Git LFS, GitHub CLI"
echo "  âœ“ Zsh, Oh My Zsh, Powerlevel10k"
echo "  âœ“ iTerm2"
if [[ ! "$INSTALL_CURSOR" =~ ^[Nn]$ ]]; then
    echo "  âœ“ Cursor Desktop"
fi
echo "  âœ“ Git scripts symlinks"
echo "  âœ“ Useful aliases (cdg, cda, cdf, cds)"
echo ""

prompt "Next Steps:"
echo ""
echo "1. Reload your shell configuration:"
echo "   source ~/.zshrc"
echo "   (or restart your terminal)"
echo ""
echo "2. Verify your setup:"
echo "   - Check Git: git --version"
echo "   - Check GitHub CLI: gh --version"
echo "   - Test aliases: cdg, cda, cdf, cds"
echo ""
if [ -n "$ITERM2_CONFIG_FILE" ] && [ -f "$ITERM2_CONFIG_FILE" ]; then
    echo "3. Import iTerm2 configuration:"
    echo "   Double-click: $ITERM2_CONFIG_FILE"
    echo ""
fi
echo "4. Configure Powerlevel10k (if not done):"
echo "   p10k configure"
echo ""

success "Happy coding! ðŸš€"
