#!/bin/bash

# git_create_from_local
# Creates a new GitHub repository from a local folder, initializes it,
# commits existing files, and pushes to remote.

set -e  # Exit on error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print error messages
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

# Function to print success messages
success() {
    echo -e "${GREEN}$1${NC}"
}

# Function to print info messages
info() {
    echo -e "${YELLOW}$1${NC}"
}

# Check if user/repo argument is provided
if [ $# -ne 1 ]; then
    error "Usage: git_create_from_local <user/repo>\nExample: git_create_from_local fortegb/test"
fi

USER_REPO="$1"

# Validate format (should contain exactly one slash)
if [[ ! "$USER_REPO" =~ ^[^/]+/[^/]+$ ]]; then
    error "Invalid format. Expected: user/repo\nExample: fortegb/test or akamlibehsafe/myproject"
fi

# Parse username and repository name
USERNAME=$(echo "$USER_REPO" | cut -d'/' -f1)
REPO_NAME=$(echo "$USER_REPO" | cut -d'/' -f2)

info "Creating repository: $USER_REPO"
info "Username: $USERNAME"
info "Repository: $REPO_NAME"

# Determine which PAT to use based on username
if [ "$USERNAME" = "fortegb" ]; then
    PAT_VAR="GH_TOKEN_fortegb"
elif [ "$USERNAME" = "akamlibehsafe" ]; then
    PAT_VAR="GH_TOKEN_akamlibehsafe"
else
    error "Unknown username: $USERNAME\nSupported users: fortegb, akamlibehsafe"
fi

# Retrieve PAT from environment
PAT="${!PAT_VAR}"

if [ -z "$PAT" ]; then
    error "PAT variable $PAT_VAR is not set.\nPlease set it in your shell configuration:\nexport $PAT_VAR=\"your_token_here\""
fi

info "Using PAT from: $PAT_VAR"

# Check if git is installed
if ! command -v git &> /dev/null; then
    error "Git is not installed. Please run git_install first."
fi

# Check if curl is installed
if ! command -v curl &> /dev/null; then
    error "curl is not installed. Please install it first."
fi

# Get current directory (absolute path)
CURRENT_DIR=$(pwd -P)
info "Working directory: $CURRENT_DIR"

# Handle Git safe.directory issue for /tmp and other potentially problematic directories
# This is a security feature in Git that requires explicit permission for certain directories
if [[ "$CURRENT_DIR" =~ ^/tmp|^/private/tmp|^/var/tmp ]]; then
    info "Detected temporary directory, ensuring Git safe.directory configuration..."
    # Check if this directory is already in safe.directory list
    SAFE_DIRS=$(git config --global --get-all safe.directory 2>/dev/null || echo "")
    if [ -z "$SAFE_DIRS" ] || ! echo "$SAFE_DIRS" | grep -Fxq "$CURRENT_DIR"; then
        git config --global --add safe.directory "$CURRENT_DIR"
        info "Added $CURRENT_DIR to Git safe.directory list"
    fi
fi

# Validate PAT by checking GitHub API authentication
info "Validating PAT token..."
PAT_CHECK=$(curl -s -w "\n%{http_code}" \
    -H "Accept: application/vnd.github.v3+json" \
    -H "Authorization: token $PAT" \
    https://api.github.com/user)

PAT_CHECK_CODE=$(echo "$PAT_CHECK" | tail -n1)
PAT_CHECK_BODY=$(echo "$PAT_CHECK" | sed '$d')

if [ "$PAT_CHECK_CODE" -eq 200 ]; then
    # Extract username from response (if jq is available)
    if command -v jq &> /dev/null; then
        AUTH_USER=$(echo "$PAT_CHECK_BODY" | jq -r '.login' 2>/dev/null || echo "unknown")
        if [ "$AUTH_USER" != "null" ] && [ -n "$AUTH_USER" ]; then
            info "PAT validated successfully (authenticated as: $AUTH_USER)"
            if [ "$AUTH_USER" != "$USERNAME" ]; then
                error "PAT token belongs to user '$AUTH_USER', but you specified '$USERNAME'.\nPlease use the correct PAT token for the '$USERNAME' account."
            fi
        else
            info "PAT validated successfully"
        fi
    else
        info "PAT validated successfully"
    fi
elif [ "$PAT_CHECK_CODE" -eq 401 ]; then
    error "Invalid PAT token. The token $PAT_VAR is not valid or has expired.\n\nPlease regenerate your token:\n1. Go to https://github.com/settings/tokens\n2. Generate a new token for the '$USERNAME' account\n3. Make sure it has the 'repo' scope\n4. Update: export $PAT_VAR=\"your_new_token_here\""
elif [ "$PAT_CHECK_CODE" -eq 403 ]; then
    error "PAT token doesn't have required permissions.\n\nYour token needs the 'repo' scope to create repositories.\n\nTo fix:\n1. Go to https://github.com/settings/tokens\n2. Edit or create a token for '$USERNAME'\n3. Enable the 'repo' scope (Full control of private repositories)\n4. Update: export $PAT_VAR=\"your_token_here\""
else
    info "Warning: Could not validate PAT (HTTP $PAT_CHECK_CODE). Continuing anyway..."
fi

# Create GitHub repository via API
info "Creating GitHub repository..."

API_RESPONSE=$(curl -s -w "\n%{http_code}" \
    -X POST \
    -H "Accept: application/vnd.github.v3+json" \
    -H "Authorization: token $PAT" \
    -H "Content-Type: application/json" \
    -d "{\"name\":\"$REPO_NAME\",\"private\":false}" \
    https://api.github.com/user/repos)

HTTP_CODE=$(echo "$API_RESPONSE" | tail -n1)
API_BODY=$(echo "$API_RESPONSE" | sed '$d')

if [ "$HTTP_CODE" -eq 201 ]; then
    success "Repository created successfully on GitHub"
elif [ "$HTTP_CODE" -eq 401 ]; then
    error "Authentication failed. Your PAT token may be invalid or expired.\n\nPlease verify:\n1. The PAT token $PAT_VAR is correct\n2. The token hasn't expired\n3. Regenerate the token if needed: https://github.com/settings/tokens\n\nResponse: $API_BODY"
elif [ "$HTTP_CODE" -eq 403 ]; then
    error "Access denied. Your PAT token doesn't have the required permissions.\n\nThis usually means:\n1. The PAT doesn't have the 'repo' scope enabled\n2. The PAT belongs to a different GitHub account\n3. The PAT has expired\n\nTo fix this:\n1. Go to https://github.com/settings/tokens\n2. Find or create a token for the '$USERNAME' account\n3. Make sure it has the 'repo' scope (Full control of private repositories) checked\n4. Update your environment variable:\n   export $PAT_VAR=\"your_new_token_here\"\n5. Source your shell config file or restart your terminal\n\nResponse: $API_BODY"
elif [ "$HTTP_CODE" -eq 422 ]; then
    # Repository might already exist
    if echo "$API_BODY" | grep -q "already exists"; then
        info "Repository already exists on GitHub, continuing..."
    else
        error "Failed to create repository. GitHub API error:\n$API_BODY"
    fi
else
    error "Failed to create repository. HTTP status: $HTTP_CODE\nResponse: $API_BODY"
fi

# Initialize Git repository if not already initialized
if [ ! -d ".git" ]; then
    info "Initializing Git repository..."
    git init
    success "Git repository initialized"
else
    info "Git repository already initialized"
fi

# Determine default branch name (prefer main, fallback to master)
# Check what the default branch is set to, or use main
DEFAULT_BRANCH=$(git config --global init.defaultBranch 2>/dev/null || echo "main")
if [ "$DEFAULT_BRANCH" != "main" ] && [ "$DEFAULT_BRANCH" != "master" ]; then
    DEFAULT_BRANCH="main"
fi

# Check if we're already on a branch
CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "")
if [ -z "$CURRENT_BRANCH" ]; then
    # We'll create the branch when we make the first commit
    # For now, just note that we need to create it
    CURRENT_BRANCH="$DEFAULT_BRANCH"
fi

# Add or update remote origin
REMOTE_URL="https://${PAT}@github.com/${USER_REPO}.git"
if git remote get-url origin &>/dev/null; then
    info "Updating remote origin..."
    git remote set-url origin "$REMOTE_URL"
else
    info "Adding remote origin..."
    git remote add origin "$REMOTE_URL"
fi
success "Remote origin configured"

# Check if we have any commits already
HAS_COMMITS=false
if git rev-parse --verify HEAD &>/dev/null; then
    HAS_COMMITS=true
    CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "$DEFAULT_BRANCH")
fi

# Stage and commit files if any exist
if [ -n "$(find . -maxdepth 1 -not -name '.git' -not -name '.' -not -name '..' 2>/dev/null)" ]; then
    info "Staging files..."
    git add .
    
    # Check if there are changes to commit
    if ! git diff --staged --quiet 2>/dev/null || [ -n "$(git ls-files --others --exclude-standard)" ]; then
        # If no branch exists yet, create one when we commit
        if [ "$HAS_COMMITS" = false ]; then
            info "Creating initial commit on $DEFAULT_BRANCH branch..."
            git commit -m "Initial commit" || error "Failed to create commit"
        else
            info "Creating commit..."
            git commit -m "Initial commit" || error "Failed to create commit"
        fi
        success "Commit created"
        HAS_COMMITS=true
    else
        info "No changes to commit"
    fi
else
    info "No files to commit (empty repository)"
fi

# If we still don't have any commits, create an empty one
# This is required to have a branch that can be pushed
if [ "$HAS_COMMITS" = false ]; then
    info "Creating empty initial commit for empty repository..."
    git commit --allow-empty -m "Initial commit (empty repository)" || error "Failed to create empty commit"
    success "Empty initial commit created"
    HAS_COMMITS=true
fi

# Ensure we're on the correct branch (it should exist now after the commit)
CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "$DEFAULT_BRANCH")
if [ "$CURRENT_BRANCH" != "$DEFAULT_BRANCH" ]; then
    # Switch to default branch if we're on a different one
    git checkout -b "$DEFAULT_BRANCH" 2>/dev/null || git checkout "$DEFAULT_BRANCH" 2>/dev/null || true
    CURRENT_BRANCH="$DEFAULT_BRANCH"
fi

# Push to remote
info "Pushing to remote repository..."
info "Pushing branch: $CURRENT_BRANCH"

set +e
git push -u origin "$CURRENT_BRANCH" 2>&1
PUSH_ERROR=$?
set -e

if [ $PUSH_ERROR -eq 0 ]; then
    success "Successfully pushed to remote repository"
    success "\nRepository is ready at: https://github.com/$USER_REPO"
else
    error "Failed to push to remote repository.\n\nThis might happen if:\n1. The repository already exists on GitHub with different content\n2. Network connectivity issues\n3. Authentication problems\n\nTry manually: git push -u origin $CURRENT_BRANCH"
fi

